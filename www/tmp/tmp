------WebKitFormBoundaryxyz
Content-Disposition: form-data; name="username"

JohnDoe
------WebKitFormBoundaryxyz
Content-Disposition: form-data; name="email"

johndoe@example.com
------WebKitFormBoundaryxyz
Content-Disposition: form-data; name="profile_picture"; filename="avatar.png"
Content-Type: image/png

(binary file content here)
------WebKitFormBoundaryxyz--









// *****
	file.gcount() => Returns the number of characters last read
	file.tellg()  => Gets the current position of the file pointer for_ reading.
	file.tellp()  => Gets the current position of the file pointer for_ writing.
	file.seekg()  => Sets the file pointer (get pointer) to a specific position for_ reading.
	file.seekp()  => Sets the file pointer (put pointer) to a specific position for_ writing.
						file.seekp(200, std::ios::beg);  // Move to the 200th byte from the beginning
	std.streampos => is a type used to represent positions within a file.


	// Comparing
	// std::getline()
	// std::string::compare
	// std::string::find
// *****





/*
	// read line by line
	std::string line;
	while (std::getline(MultiPartData, line))
	{
		if (line[line.length() - 1] != '\r' && state != PARSE::STATE_CONTENT_FILE_DATA) // exept file data, all lines should end with \r\n
			return (req._Error_msg = "Invalid Line Ending", 0);

		line += "\n";
		switch (state)
		{
		case PARSE::STATE_BOUNDARY:
		{
			if (line == "--" + req._boundary + "\r\n") // fix this.
			{
				state = PARSE::STATE_CONTENT_DISPOSITION;
				break;
			}
			else
				return (req._Error_msg = "Invalid Boundary", 0);
		}
		case PARSE::STATE_CONTENT_DISPOSITION:
		{
			if (line.find("Content-Disposition: form-data;") == std::string::npos)
				return (req._Error_msg = "Invalid Content-Disposition", 0);

			if (line.find("name=") != std::string::npos)
				state = PARSE::STATE_CONTENT_FIELD_NAME;
			else
				return (req._Error_msg = "Invalid Field Name", 0);
		}
		/* fall through //
		case PARSE::STATE_CONTENT_FIELD_NAME:
		{
			field_name = line.substr(line.find("name=") + 6);
			field_name = field_name.substr(0, field_name.find("\""));

			if (line.find("filename=") != std::string::npos)
				state = PARSE::STATE_CONTENT_FILE_NAME;
			else
			{
				state = PARSE::STATE_CONTENT_EMPTY_LINE;
				break;
			}
		}
		/* fall through //
		case PARSE::STATE_CONTENT_FILE_NAME: // Field value is a file
		{
			field_value = line.substr(line.find("filename=") + 10);
			field_value = field_value.substr(0, field_value.find("\""));

			// Check if file name is empty
			if (field_value.empty())
				return (req._Error_msg = "Invalid File Name", 0);

			// If file exists
			std::ifstream curr_file_check((fullDir + field_value).c_str(), std::ios::in);
			if (curr_file_check.is_open())
				return (req._Error_msg = "File already exists", 0);

			// Open file
			curr_file.open((fullDir + field_value).c_str(), std::ios::binary);
			if (!curr_file.is_open())
				return (req._Error_msg = "Could not open file", -1);
			state = PARSE::STATE_CONTENT_TYPE;
			break;
		}
		case PARSE::STATE_CONTENT_EMPTY_LINE:
		{
			if (line == "\r\n")
			{
				state = PARSE::STATE_CONTENT_FIELD_VALUE;
				break;
			}
			else
				return (req._Error_msg = "Invalid Empty Line", 0);
		}
		case PARSE::STATE_CONTENT_FIELD_VALUE:
		{
			field_value = line.substr(0, line.length() - 2); // remove \r\n

			req._Fields[field_name] = field_value;
			state = PARSE::STATE_BOUNDARY;
			break;
		}
		case PARSE::STATE_CONTENT_TYPE:
		{
			if (line.find("Content-Type:") != std::string::npos)
			{
				req._Fields[field_name] = field_value;
				state = PARSE::STATE_CONTENT_EMPTY_LINE_AFTER_TYPE;
				break;
			}
			else
				return (req._Error_msg = "Invalid Content-Type", 0);
		}
		case PARSE::STATE_CONTENT_EMPTY_LINE_AFTER_TYPE:
		{
			if (line == "\r\n")
			{
				state = PARSE::STATE_CONTENT_FILE_DATA;
				break;
			}
			else
				return (req._Error_msg = "Invalid Empty Line After Type", 0);
		}
		case PARSE::STATE_CONTENT_FILE_DATA:
		{
			if (line == "--" + req._boundary + "--\r\n")
			{
				curr_file.close();
				state = PARSE::STATE_BOUNDARY_END;
				break;
			}
			else if (line == "--" + req._boundary + "\r\n")
			{
				curr_file.close();
				state = PARSE::STATE_CONTENT_DISPOSITION;
				break;
			}
			else
			{
				curr_file << line; // remove \r\n
				break;
			}
		}
		case PARSE::STATE_EMPTY_LINE_BEFORE_BOUNDARY_END:
		{
			if (line == "\r\n")
			{
				state = PARSE::STATE_BOUNDARY_END;
				break;
			}
			else
				return (req._Error_msg = "Invalid Empty Line Before Boundary End", 0);
		}
		case PARSE::STATE_BOUNDARY_END:
		{
			if (line == "--\r\n")
			{
				state = PARSE::STATE_BOUNDARY;
				break;
			}
			else
				return (req._Error_msg = "Invalid Boundary End", 0);
		}
		default:
			break;
		}
	}

*/









	if (!req._initialized)
	{
		// Seting up upload dir
		std::string Upload_dir = req._location_res["upload"];
		std::string Root = req._location_res["root"];
		Root += (Root[Root.length() - 1] == '/' ? "" : "/");
		Upload_dir += (Upload_dir[Upload_dir.length() - 1] == '/' ? "" : "/");
		req._fullDir = Root + Upload_dir;
		// Open tmp file
		// req._tmp_file.open((req._tmp_file_name).c_str(), std::ios::binary);
		// init
		req._initialized = true;
		req.multipart_state = PARSE::STATE_BOUNDARY;
		// if upload dirr is exist
		if (!isDirectory(req._fullDir))
			return (req._Error_msg = "Unacessible upload folder", -1);
	}

	std::ifstream tmp_file;
	tmp_file.open("./www/tmp/tmp", std::ios::binary);
	if (!tmp_file.is_open())
		return (req._Error_msg = "Could not open tmp file", -1);

	int ChunkSize = 16384;
	char Buffer[ChunkSize];

	tmp_file.read(Buffer, ChunkSize);

	switch (req.multipart_state)
	{
	case PARSE::STATE_BOUNDARY:
	{
		std::string Boundary = "--" + req._boundary;
		std::string BoundaryFromBuffer = std::string(Buffer).substr(0, Boundary.length());

		if (Boundary.compare(0, Boundary.length(), BoundaryFromBuffer) == 0)
		{
			std::cout << "Boundary is Okey." << std::endl;
			req.multipart_state = PARSE::STATE_CONTENT_DISPOSITION;
			req._curr_tmpfile_pos +=  Boundary.length();
		}
		else
			return (req._Error_msg = "Invalid Boundary", 0);
	}
	/* fall through */
	case PARSE::STATE_CONTENT_DISPOSITION:
	{

	}
	default:
		break;
	}

	std::string data = FieldsMapStringify(req._Fields);
	Response res;
	res.WithHttpVersion("HTTP/1.1")
		.WithStatus(201)
		.setDefaultHeaders()
		.WithHeader("Content-Type", "application/json")
		.WithBody("{\"data\": " + data + "}")
		.Generate()
		.Send(client_socket);
	return (1);